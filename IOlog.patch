diff --git a/include/backend_common.h b/include/backend_common.h
index f2fa01f..1f1b45a 100644
--- a/include/backend_common.h
+++ b/include/backend_common.h
@@ -85,6 +85,7 @@ struct spectra_info {
     long long *num_spec;   // Number of spectra per file
     long long *num_pad;    // Number of padding samples after each file
     int (*get_rawblock)(float *, struct spectra_info *, int *);  // Raw data block function pointer
+    int (*get_rawblock_log)(float *, struct spectra_info *, int *, long long *, long *);  // Raw data block function pointer
     long long (*offset_to_spectra)(long long, struct spectra_info *);  // Shift into file(s) function pointer
 };
 
@@ -105,6 +106,7 @@ int read_psrdata(float *fdata, int numspect, struct spectra_info *s, int *delays
 void get_channel(float chandat[], int channum, int numsubints, float rawdata[], struct spectra_info *s);
 int prep_subbands(float *fdata, float *rawdata, int *delays, int numsubbands, struct spectra_info *s, int transpose, int *maskchans, int *nummasked, mask *obsmask);
 int read_subbands(float *fdata, int *delays, int numsubbands, struct spectra_info *s, int transpose, int *padding, int *maskchans, int *nummasked, mask *obsmask);
+int read_subbands_log(float *fdata, int *delays, int numsubbands, struct spectra_info *s, int transpose, int *padding, int *maskchans, int *nummasked, mask * obsmask, long long *data_size, long *total_microseconds);
 void flip_band(float *fdata, struct spectra_info *s);
 int *get_ignorechans(char *ignorechans_str, int minchan, int maxchan, int *num_ignorechans, char **filestr);
 
diff --git a/include/prepfold_cmd.h b/include/prepfold_cmd.h
index 2f2e4d6..f762b24 100644
--- a/include/prepfold_cmd.h
+++ b/include/prepfold_cmd.h
@@ -252,6 +252,8 @@ typedef struct s_Cmdline {
   /*@null*/char **argv;
   /***** the whole command line concatenated */
   char *full_cmd_line;
+  /***** -IOlog: Print IO transfer log */
+  char IOlogP;
 } Cmdline;
 
 
diff --git a/include/prepsubband_cmd.h b/include/prepsubband_cmd.h
index 9b53297..e0f52f3 100644
--- a/include/prepsubband_cmd.h
+++ b/include/prepsubband_cmd.h
@@ -108,6 +108,8 @@ typedef struct s_Cmdline {
   /*@null*/char **argv;
   /***** the whole command line concatenated */
   char *full_cmd_line;
+  /***** -IOlog: Print IO transfer log */
+  char IOlogP;
 } Cmdline;
 
 
diff --git a/include/psrfits.h b/include/psrfits.h
index d46ae48..e1939ba 100644
--- a/include/psrfits.h
+++ b/include/psrfits.h
@@ -5,3 +5,4 @@ int is_PSRFITS(char *filename);
 void read_PSRFITS_files(struct spectra_info *s);
 long long offset_to_PSRFITS_spectra(long long specnum, struct spectra_info *s);
 int get_PSRFITS_rawblock(float *fdata, struct spectra_info *s, int *padding);
+int get_PSRFITS_rawblock_log(float *fdata, struct spectra_info *s, int *padding, long long *data_size, long *total_microseconds);
\ No newline at end of file
diff --git a/include/realfft_cmd.h b/include/realfft_cmd.h
index 7be12b9..25c9500 100644
--- a/include/realfft_cmd.h
+++ b/include/realfft_cmd.h
@@ -32,6 +32,8 @@ typedef struct s_Cmdline {
   /*@null*/char **argv;
   /***** the whole command line concatenated */
   char *full_cmd_line;
+  /***** -IOlog: Print IO transfer log */
+  char IOlogP;
 } Cmdline;
 
 
diff --git a/src/backend_common.c b/src/backend_common.c
index 1d56029..557608f 100644
--- a/src/backend_common.c
+++ b/src/backend_common.c
@@ -810,6 +810,67 @@ int read_subbands(float *fdata, int *delays, int numsubbands,
     }
 }
 
+int read_subbands_log(float *fdata, int *delays, int numsubbands,
+                  struct spectra_info *s, int transpose, int *padding,
+                  int *maskchans, int *nummasked, mask * obsmask, long long *data_size, long *total_microseconds)
+// This routine reads a spectral block/subint from the input raw data
+// files. The routine uses dispersion delays in 'delays' to
+// de-disperse the data into 'numsubbands' subbands.  It stores the
+// resulting data in vector 'fdata' of length 'numsubbands' *
+// 's->spectra_per_subint'.  The low freq subband is stored first,
+// then the next highest subband etc, with 's->spectra_per_subint'
+// floating points per subband.  It returns the # of points read if
+// successful, 0 otherwise. If padding is returned as 1, then padding
+// was added and statistics should not be calculated.  'maskchans' is
+// an array of length numchans which contains a list of the number of
+// channels that were masked.  The # of channels masked is returned in
+// 'nummasked'.  'obsmask' is the mask structure to use for masking.
+// If 'transpose'==0, the data will be kept in time order instead of
+// arranged by subband as above.
+{
+    static int firsttime = 1;
+    static float *frawdata;
+
+    if (firsttime) {
+        // Check to make sure there isn't more dispersion across a
+        // subband than time in a block of data
+        if (delays[0] > s->spectra_per_subint) {
+            perror("\nError: there is more dispersion across a subband than time\n"
+                   "in a block of data.  Increase spectra_per_subint if possible.");
+            exit(-1);
+        }
+        // Needs to be twice as large for buffering if adding observations together
+        frawdata = gen_fvect(2 * s->num_channels * s->spectra_per_subint);
+        // if (!get_PSRFITS_rawblock_log(frawdata, s, padding, data_size, total_microseconds)) {
+        //     perror("Error: problem reading the raw data file in read_subbands()");
+        //     exit(-1);
+        // }
+        if (!s->get_rawblock_log(frawdata, s, padding, data_size, total_microseconds)) {
+            perror("Error: problem reading the raw data file in read_subbands()");
+            exit(-1);
+        }
+        if (0 != prep_subbands(fdata, frawdata, delays, numsubbands, s,
+                               transpose, maskchans, nummasked, obsmask)) {
+            perror("Error: problem initializing prep_subbands() in read_subbands()");
+            exit(-1);
+        }
+        firsttime = 0;
+    }
+    // if (!get_PSRFITS_rawblock_log(frawdata, s, padding, data_size, total_microseconds)) {
+    //     return 0;
+    // }
+    if (!s->get_rawblock_log(frawdata, s, padding, data_size, total_microseconds)) {
+        return 0;
+    }
+    if (prep_subbands(fdata, frawdata, delays, numsubbands, s, transpose,
+                      maskchans, nummasked, obsmask) == s->spectra_per_subint) {
+        currentspectra += s->spectra_per_subint;
+        return s->spectra_per_subint;
+    } else {
+        return 0;
+    }
+}
+
 
 void flip_band(float *fdata, struct spectra_info *s)
 // Flip the bandpass
diff --git a/src/prepfold.c b/src/prepfold.c
index 30d56c2..9ab3650 100644
--- a/src/prepfold.c
+++ b/src/prepfold.c
@@ -400,6 +400,9 @@ int main(int argc, char *argv[])
         }
     }
 
+    long long data_size = 0;
+    long total_microseconds = 0;
+
     /* Manipulate the file names we will use  */
 
     {
@@ -1279,10 +1282,16 @@ int main(int argc, char *argv[])
             for (jj = 0; jj < reads_per_part; jj++) {
                 double fold_time0;
 
-                if (RAWDATA) {
-                    numread =
-                        read_subbands(data, idispdts, cmd->nsub, &s, 1, &padding,
+                if (RAWDATA)
+                {
+                    if (!cmd->IOlogP)
+                    {
+                        numread = read_subbands(data, idispdts, cmd->nsub, &s, 1, &padding,
                                       maskchans, &nummasked, &obsmask);
+                    }else{
+                        numread = read_subbands_log(data, idispdts, cmd->nsub, &s, 1, &padding,
+                                      maskchans, &nummasked, &obsmask, &data_size, &total_microseconds);
+                    }
                 } else if (insubs) {
                     numread = read_PRESTO_subbands(s.files, s.num_files, data, recdt,
                                                    maskchans, &nummasked, &obsmask,
@@ -1832,5 +1841,8 @@ int main(int argc, char *argv[])
         vect_free(idispdts);
     }
     printf("Done.\n\n");
+    if(cmd->IOlogP){
+        printf("IOlog: %s read %.3f GB data, use %.3f s, %.3f GB/s\n", cmd->full_cmd_line, (double)data_size/(1024.0*1024.0*1024.0), (double)total_microseconds/(1000000), ((double)data_size/(1024.0*1024.0*1024.0))/((double)total_microseconds/(1000000)));
+    }
     return (0);
 }
diff --git a/src/prepfold_cmd.c b/src/prepfold_cmd.c
index 7f888ac..de9e6d8 100644
--- a/src/prepfold_cmd.c
+++ b/src/prepfold_cmd.c
@@ -264,7 +264,9 @@ static Cmdline cmd = {
   /* argc = */ 0,
   /* argv = */ (char**)0,
   /***** the original command line concatenated */
-  /* full_cmd_line = */ NULL
+  /* full_cmd_line = */ NULL,
+  /***** -IOlog: Print IO transfer log */
+  /* IOlogP = */ 0
 };
 
 /*@=null*/
@@ -1711,6 +1713,14 @@ showOptionValues(void)
       printf("  value = `%.40g'\n", cmd.offset);
     }
   }
+
+  /***** -IOlog: Print IO transfer log */
+  if( !cmd.IOlogP ) {
+    printf("-IOlog not found.\n");
+  } else {
+    printf("-IOlog found:\n");
+  }
+
   if( !cmd.argc ) {
     printf("no remaining parameters in argv\n");
   } else {
@@ -2443,6 +2453,11 @@ parseCmdline(int argc, char **argv)
       continue;
     }
 
+    if( 0==strcmp("-IOlog", argv[i]) ) {
+      cmd.IOlogP = 1;
+      continue;
+    }
+
     if( argv[i][0]=='-' ) {
       fprintf(stderr, "\n%s: unknown option `%s'\n\n",
               Program, argv[i]);
diff --git a/src/prepsubband.c b/src/prepsubband.c
index 4ae4eb0..389d8fd 100644
--- a/src/prepsubband.c
+++ b/src/prepsubband.c
@@ -35,7 +35,7 @@ static int read_PRESTO_subbands(FILE * infiles[], int numfiles,
 static int get_data(float **outdata, int blocksperread,
                     struct spectra_info *s,
                     mask * obsmask, int *idispdts, int **offsets,
-                    int *padding, short **subsdata);
+                    int *padding, short **subsdata, long long *data_size, long *total_microseconds);
 static void update_infodata(infodata * idata, long datawrote, long padwrote,
                             int *barybins, int numbarybins, int downsamp);
 static void print_percent_complete(int current, int number);
@@ -255,6 +255,9 @@ int main(int argc, char *argv[])
 
     /* Determine the output file names and open them */
 
+    long long data_size = 0;
+    long total_microseconds = 0;
+
     datafilenm = (char *) calloc(strlen(cmd->outfile) + 20, 1);
     if (!cmd->subP) {
         printf("Writing output data to:\n");
@@ -405,7 +408,7 @@ int main(int argc, char *argv[])
         else
             outdata = gen_fmatrix(cmd->numdms, worklen / cmd->downsamp);
         numread = get_data(outdata, blocksperread, &s,
-                           &obsmask, idispdt, offsets, &padding, subsdata);
+                           &obsmask, idispdt, offsets, &padding, subsdata, &data_size, &total_microseconds);
 
         while (numread == worklen) {
 
@@ -439,7 +442,7 @@ int main(int argc, char *argv[])
                 break;
 
             numread = get_data(outdata, blocksperread, &s,
-                               &obsmask, idispdt, offsets, &padding, subsdata);
+                               &obsmask, idispdt, offsets, &padding, subsdata, &data_size, &total_microseconds);
         }
         datawrote = totwrote;
 
@@ -564,7 +567,7 @@ int main(int argc, char *argv[])
         else
             outdata = gen_fmatrix(cmd->numdms, worklen / cmd->downsamp);
         numread = get_data(outdata, blocksperread, &s,
-                           &obsmask, idispdt, offsets, &padding, subsdata);
+                           &obsmask, idispdt, offsets, &padding, subsdata, &data_size, &total_microseconds);
 
         while (numread == worklen) {    /* Loop to read and write the data */
             int numwritten = 0;
@@ -661,7 +664,7 @@ int main(int argc, char *argv[])
                 break;
 
             numread = get_data(outdata, blocksperread, &s,
-                               &obsmask, idispdt, offsets, &padding, subsdata);
+                               &obsmask, idispdt, offsets, &padding, subsdata, &data_size, &total_microseconds);
         }
     }
 
@@ -779,6 +782,9 @@ int main(int argc, char *argv[])
         vect_free(ttoa);
         vect_free(diffbins);
     }
+    if(cmd->IOlogP){
+        printf("IOlog: %s read %.3f GB data, use %.3f s, %.3f GB/s\n", cmd->full_cmd_line, (double)data_size/(1024.0*1024.0*1024.0), (double)total_microseconds/(1000000), ((double)data_size/(1024.0*1024.0*1024.0))/((double)total_microseconds/(1000000)));
+    }
     return (0);
 }
 
@@ -919,7 +925,7 @@ static int read_PRESTO_subbands(FILE * infiles[], int numfiles,
 static int get_data(float **outdata, int blocksperread,
                     struct spectra_info *s,
                     mask * obsmask, int *idispdts, int **offsets,
-                    int *padding, short **subsdata)
+                    int *padding, short **subsdata, long long *data_size, long *total_microseconds)
 {
     static int firsttime = 1, *maskchans = NULL, blocksize;
     static int worklen, dsworklen;
@@ -963,9 +969,16 @@ static int get_data(float **outdata, int blocksperread,
         if (RAWDATA || insubs) {
             for (ii = 0; ii < blocksperread; ii++) {
                 if (RAWDATA)
-                    numread = read_subbands(currentdata + ii * blocksize, idispdts,
-                                            cmd->nsub, s, 0, &tmppad,
-                                            maskchans, &nummasked, obsmask);
+                    if (!cmd->IOlogP)
+                    {
+                        numread = read_subbands(currentdata + ii * blocksize, idispdts,
+                                                cmd->nsub, s, 0, &tmppad,
+                                                maskchans, &nummasked, obsmask);
+                    }else{
+                        numread = read_subbands_log(currentdata + ii * blocksize, idispdts,
+                                                cmd->nsub, s, 0, &tmppad,
+                                                maskchans, &nummasked, obsmask, data_size, total_microseconds);
+                    }
                 else if (insubs)
                     numread = read_PRESTO_subbands(s->files, s->num_files,
                                                    currentdata + ii * blocksize,
diff --git a/src/prepsubband_cmd.c b/src/prepsubband_cmd.c
index d57b0cb..c8d7765 100644
--- a/src/prepsubband_cmd.c
+++ b/src/prepsubband_cmd.c
@@ -120,7 +120,9 @@ static Cmdline cmd = {
   /* argc = */ 0,
   /* argv = */ (char**)0,
   /***** the original command line concatenated */
-  /* full_cmd_line = */ NULL
+  /* full_cmd_line = */ NULL,
+  /***** -IOlog: Print IO transfer log */
+  /* IOlogP = */ 0
 };
 
 /*@=null*/
@@ -1121,6 +1123,14 @@ showOptionValues(void)
       printf("  value = `%s'\n", cmd.ignorechanstr);
     }
   }
+
+  /***** -IOlog: Print IO transfer log */
+  if( !cmd.IOlogP ) {
+    printf("-IOlog not found.\n");
+  } else {
+    printf("-IOlog found:\n");
+  }
+
   if( !cmd.argc ) {
     printf("no remaining parameters in argv\n");
   } else {
@@ -1442,6 +1452,11 @@ parseCmdline(int argc, char **argv)
       continue;
     }
 
+    if( 0==strcmp("-IOlog", argv[i]) ) {
+      cmd.IOlogP = 1;
+      continue;
+    }
+
     if( argv[i][0]=='-' ) {
       fprintf(stderr, "\n%s: unknown option `%s'\n\n",
               Program, argv[i]);
diff --git a/src/prepsubband_cu.c b/src/prepsubband_cu.c
index 52fdad5..f22dca0 100644
--- a/src/prepsubband_cu.c
+++ b/src/prepsubband_cu.c
@@ -56,7 +56,7 @@ static int read_PRESTO_subbands(FILE *infiles[], int numfiles,
 static int get_data_offset(float **outdata, int blocksperread,
                            struct spectra_info *s,
                            mask *obsmask, int *idispdts,
-                           int *padding, short **subsdata);
+                           int *padding, short **subsdata, long long *data_size, long *total_microseconds);
 static void update_infodata(infodata *idata, long datawrote, long padwrote,
                             int *barybins, int numbarybins, int downsamp);
 static void print_percent_complete(int current, int number);
@@ -257,9 +257,10 @@ int main(int argc, char *argv[])
             read_mask(cmd->maskfile, &obsmask);
             printf("Read mask information from '%s'\n\n", cmd->maskfile);
             if ((obsmask.numchan != idata.num_chan) ||
-                (fabs(obsmask.mjd - (idata.mjd_i + idata.mjd_f)) > 1e-9)) {
-                    printf("WARNING!: maskfile has different number of channels or start MJD than raw data! Exiting.\n\n");
-                    exit(1);
+                (fabs(obsmask.mjd - (idata.mjd_i + idata.mjd_f)) > 1e-9))
+            {
+                printf("WARNING!: maskfile has different number of channels or start MJD than raw data! Exiting.\n\n");
+                exit(1);
             }
             good_padvals = determine_padvals(cmd->maskfile, &obsmask, s.padvals);
         }
@@ -309,6 +310,9 @@ int main(int argc, char *argv[])
 
     /* Determine the output file names and open them */
 
+    long long data_size = 0;
+    long total_microseconds = 0;
+
     datafilenm = (char *)calloc(strlen(cmd->outfile) + 20, 1);
     if (!cmd->subP)
     {
@@ -492,7 +496,7 @@ int main(int argc, char *argv[])
         else
             outdata = gen_fmatrix(cmd->numdms, worklen / cmd->downsamp);
         numread = get_data_offset(outdata, blocksperread, &s,
-                                  &obsmask, idispdt, &padding, subsdata);
+                                  &obsmask, idispdt, &padding, subsdata, &data_size, &total_microseconds);
 
         while (numread == worklen)
         {
@@ -528,7 +532,7 @@ int main(int argc, char *argv[])
                 break;
 
             numread = get_data_offset(outdata, blocksperread, &s,
-                                      &obsmask, idispdt, &padding, subsdata);
+                                      &obsmask, idispdt, &padding, subsdata, &data_size, &total_microseconds);
         }
         datawrote = totwrote;
         free(offsets_host);
@@ -673,7 +677,7 @@ int main(int argc, char *argv[])
         else
             outdata = gen_fmatrix(cmd->numdms, worklen / cmd->downsamp);
         numread = get_data_offset(outdata, blocksperread, &s,
-                                  &obsmask, idispdt, &padding, subsdata);
+                                  &obsmask, idispdt, &padding, subsdata, &data_size, &total_microseconds);
 
         while (numread == worklen)
         { /* Loop to read and write the data */
@@ -778,7 +782,7 @@ int main(int argc, char *argv[])
                 break;
 
             numread = get_data_offset(outdata, blocksperread, &s,
-                                      &obsmask, idispdt, &padding, subsdata);
+                                      &obsmask, idispdt, &padding, subsdata, &data_size, &total_microseconds);
         }
         free(offsets_host);
     }
@@ -919,6 +923,9 @@ int main(int argc, char *argv[])
     cudaFree(lastdata_gpu);
     cudaFree(currentdsdata_gpu);
     cudaFree(lastdsdata_gpu);
+    if(cmd->IOlogP){
+        printf("IOlog: %s read %.3f GB data, use %.3f s, %.3f GB/s\n", cmd->full_cmd_line, (double)data_size/(1024.0*1024.0*1024.0), (double)total_microseconds/(1000000), ((double)data_size/(1024.0*1024.0*1024.0))/((double)total_microseconds/(1000000)));
+    }
     return (0);
 }
 
@@ -1077,7 +1084,7 @@ static int read_PRESTO_subbands(FILE *infiles[], int numfiles,
 static int get_data_offset(float **outdata, int blocksperread,
                            struct spectra_info *s,
                            mask *obsmask, int *idispdts,
-                           int *padding, short **subsdata)
+                           int *padding, short **subsdata, long long *data_size, long *total_microseconds)
 {
     static int firsttime = 1, *maskchans = NULL, blocksize;
     static int worklen, dsworklen;
@@ -1121,9 +1128,18 @@ static int get_data_offset(float **outdata, int blocksperread,
             for (ii = 0; ii < blocksperread; ii++)
             {
                 if (RAWDATA)
-                    numread = read_subbands(currentdata + ii * blocksize, idispdts,
-                                            cmd->nsub, s, 0, &tmppad,
-                                            maskchans, &nummasked, obsmask);
+                {
+                    if (!cmd->IOlogP)
+                    {
+                        numread = read_subbands(currentdata + ii * blocksize, idispdts,
+                                                cmd->nsub, s, 0, &tmppad,
+                                                maskchans, &nummasked, obsmask);
+                    }else{
+                        numread = read_subbands_log(currentdata + ii * blocksize, idispdts,
+                                                cmd->nsub, s, 0, &tmppad,
+                                                maskchans, &nummasked, obsmask, data_size, total_microseconds);
+                    }
+                }
                 else if (insubs)
                     numread = read_PRESTO_subbands(s->files, s->num_files,
                                                    currentdata + ii * blocksize,
diff --git a/src/psrfits.c b/src/psrfits.c
index 17e5517..9f799eb 100644
--- a/src/psrfits.c
+++ b/src/psrfits.c
@@ -3,7 +3,7 @@
 #include "presto.h"
 #include "mask.h"
 #include "psrfits.h"
-
+#include <sys/time.h>
 #define DEBUG_OUT 1
 
 static unsigned char *cdatabuffer;
@@ -15,7 +15,7 @@ extern double slaCldj(int iy, int im, int id, int *j);
 extern void add_padding(float *fdata, float *padding, int numchan, int numtopad);
 
 void get_PSRFITS_subint(float *fdata, unsigned char *cdata, struct spectra_info *s);
-
+void get_PSRFITS_subint_log(float *fdata, unsigned char *cdata, struct spectra_info *s, long long *data_size, long *total_microseconds);
 double DATEOBS_to_MJD(char *dateobs, int *mjd_day, double *mjd_fracday)
 // Convert DATE-OBS string from PSRFITS primary HDU to a MJD
 {
@@ -39,7 +39,8 @@ int is_PSRFITS(char *filename)
 
     // Read the primary HDU
     fits_open_file(&fptr, filename, READONLY, &status);
-    if (status) {
+    if (status)
+    {
         fits_get_errstatus(status, err_text);
         printf("Error %d opening %s : %s\n", status, filename, err_text);
         fits_close_file(fptr, &status);
@@ -48,14 +49,18 @@ int is_PSRFITS(char *filename)
 
     // Make the easy check first
     fits_read_key(fptr, TSTRING, "FITSTYPE", ctmp, comment, &status);
-    if (status) {
+    if (status)
+    {
         fits_get_errstatus(status, err_text);
         printf("Error %d reading 'FITSTYPE' from %s : %s\n",
                status, filename, err_text);
         fits_close_file(fptr, &status);
         return 0;
-    } else {
-        if (strcmp(ctmp, "PSRFITS")) {
+    }
+    else
+    {
+        if (strcmp(ctmp, "PSRFITS"))
+        {
             printf("Error 'FITSTYPE' is not 'PSRFITS' in %s\n", filename);
             fits_close_file(fptr, &status);
             return 0;
@@ -64,78 +69,103 @@ int is_PSRFITS(char *filename)
 
     // See if the data are search-mode
     fits_read_key(fptr, TSTRING, "OBS_MODE", ctmp, comment, &status);
-    if (status) {
+    if (status)
+    {
         fits_get_errstatus(status, err_text);
         printf("Error %d reading 'OBS_MODE' from %s : %s\n",
                status, filename, err_text);
         fits_close_file(fptr, &status);
         return 0;
-    } else {
-        if ((strcmp(ctmp, "SEARCH") && strcmp(ctmp, "SRCH"))) {
+    }
+    else
+    {
+        if ((strcmp(ctmp, "SEARCH") && strcmp(ctmp, "SRCH")))
+        {
             printf("Error 'OBS_MODE' is not 'SEARCH' in %s\n", filename);
             fits_close_file(fptr, &status);
             return 0;
         }
     }
     fits_close_file(fptr, &status);
-    return 1;                   // it is search-mode  PSRFITS
+    return 1; // it is search-mode  PSRFITS
 }
 
-#define check_read_status(name) {                                   \
-        if (status) {\
-            fits_get_errstatus(status, err_text); \
+#define check_read_status(name)                                           \
+    {                                                                     \
+        if (status)                                                       \
+        {                                                                 \
+            fits_get_errstatus(status, err_text);                         \
             printf("Error %d reading %s : %s\n", status, name, err_text); \
-            status=0;      \
-        }                                                               \
+            status = 0;                                                   \
+        }                                                                 \
     }
 
-#define get_hdr_string(name, param) {                                   \
+#define get_hdr_string(name, param)                                               \
+    {                                                                             \
         fits_read_key(s->fitsfiles[ii], TSTRING, (name), ctmp, comment, &status); \
-        if (status) {\
-            fits_get_errstatus(status, err_text); \
-            printf("Error %d reading %s : %s\n", status, name, err_text); \
-            if (ii==0) param[0]='\0'; \
-            if (status==KEY_NO_EXIST) status=0;                      \
-        } else {                                                     \
-            if (ii==0) strncpy((param), ctmp, 40);                          \
-            else if (strcmp((param), ctmp)!=0)                              \
-                printf("Warning!:  %s values don't match for files 0 and %d!\n", \
-                       (name), ii);                                         \
-        }                                                               \
+        if (status)                                                               \
+        {                                                                         \
+            fits_get_errstatus(status, err_text);                                 \
+            printf("Error %d reading %s : %s\n", status, name, err_text);         \
+            if (ii == 0)                                                          \
+                param[0] = '\0';                                                  \
+            if (status == KEY_NO_EXIST)                                           \
+                status = 0;                                                       \
+        }                                                                         \
+        else                                                                      \
+        {                                                                         \
+            if (ii == 0)                                                          \
+                strncpy((param), ctmp, 40);                                       \
+            else if (strcmp((param), ctmp) != 0)                                  \
+                printf("Warning!:  %s values don't match for files 0 and %d!\n",  \
+                       (name), ii);                                               \
+        }                                                                         \
     }
 
-#define get_hdr_int(name, param) {                                      \
-        fits_read_key(s->fitsfiles[ii], TINT, (name), &itmp, comment, &status); \
-        if (status) {\
-            fits_get_errstatus(status, err_text); \
-            printf("Error %d reading %s : %s\n", status, name, err_text); \
-            if (ii==0) param=0; \
-            if (status==KEY_NO_EXIST) status=0;\
-        } else {                                                          \
-            if (ii==0) param = itmp;                                        \
-            else if (param != itmp)                                         \
+#define get_hdr_int(name, param)                                                 \
+    {                                                                            \
+        fits_read_key(s->fitsfiles[ii], TINT, (name), &itmp, comment, &status);  \
+        if (status)                                                              \
+        {                                                                        \
+            fits_get_errstatus(status, err_text);                                \
+            printf("Error %d reading %s : %s\n", status, name, err_text);        \
+            if (ii == 0)                                                         \
+                param = 0;                                                       \
+            if (status == KEY_NO_EXIST)                                          \
+                status = 0;                                                      \
+        }                                                                        \
+        else                                                                     \
+        {                                                                        \
+            if (ii == 0)                                                         \
+                param = itmp;                                                    \
+            else if (param != itmp)                                              \
                 printf("Warning!:  %s values don't match for files 0 and %d!\n", \
-                       (name), ii);                                         \
-        }                                                               \
+                       (name), ii);                                              \
+        }                                                                        \
     }
 
-#define get_hdr_double(name, param) {                                   \
+#define get_hdr_double(name, param)                                                \
+    {                                                                              \
         fits_read_key(s->fitsfiles[ii], TDOUBLE, (name), &dtmp, comment, &status); \
-        if (status) {\
-            fits_get_errstatus(status, err_text); \
-            printf("Error %d reading %s : %s\n", status, name, err_text); \
-            if (ii==0.0) param=0.0; \
-            if (status==KEY_NO_EXIST) status=0;\
-        } else {                                                          \
-            if (ii==0) param = dtmp;                                        \
-            else if (param != dtmp)                                         \
-                printf("Warning!:  %s values don't match for files 0 and %d!\n", \
-                       (name), ii);                                         \
-        }                                                               \
+        if (status)                                                                \
+        {                                                                          \
+            fits_get_errstatus(status, err_text);                                  \
+            printf("Error %d reading %s : %s\n", status, name, err_text);          \
+            if (ii == 0.0)                                                         \
+                param = 0.0;                                                       \
+            if (status == KEY_NO_EXIST)                                            \
+                status = 0;                                                        \
+        }                                                                          \
+        else                                                                       \
+        {                                                                          \
+            if (ii == 0)                                                           \
+                param = dtmp;                                                      \
+            else if (param != dtmp)                                                \
+                printf("Warning!:  %s values don't match for files 0 and %d!\n",   \
+                       (name), ii);                                                \
+        }                                                                          \
     }
 
-
-
 void read_PSRFITS_files(struct spectra_info *s)
 // Read and convert PSRFITS information from a group of files
 // and place the resulting info into a spectra_info structure.
@@ -146,16 +176,17 @@ void read_PSRFITS_files(struct spectra_info *s)
     char ctmp[80], comment[120], err_text[81];
 
     s->datatype = PSRFITS;
-    s->fitsfiles = (fitsfile **) malloc(sizeof(fitsfile *) * s->num_files);
+    s->fitsfiles = (fitsfile **)malloc(sizeof(fitsfile *) * s->num_files);
     s->start_subint = gen_ivect(s->num_files);
     s->num_subint = gen_ivect(s->num_files);
-    s->start_spec = (long long *) malloc(sizeof(long long) * s->num_files);
-    s->num_spec = (long long *) malloc(sizeof(long long) * s->num_files);
-    s->num_pad = (long long *) malloc(sizeof(long long) * s->num_files);
-    s->start_MJD = (long double *) malloc(sizeof(long double) * s->num_files);
+    s->start_spec = (long long *)malloc(sizeof(long long) * s->num_files);
+    s->num_spec = (long long *)malloc(sizeof(long long) * s->num_files);
+    s->num_pad = (long long *)malloc(sizeof(long long) * s->num_files);
+    s->start_MJD = (long double *)malloc(sizeof(long double) * s->num_files);
     s->N = 0;
     s->num_beams = 1;
     s->get_rawblock = &get_PSRFITS_rawblock;
+    s->get_rawblock_log = &get_PSRFITS_rawblock_log;
     s->offset_to_spectra = &offset_to_PSRFITS_spectra;
 
     // By default, don't flip the band.  But don't change
@@ -164,10 +195,12 @@ void read_PSRFITS_files(struct spectra_info *s)
         s->apply_flipband = 0;
 
     // Step through the other files
-    for (ii = 0; ii < s->num_files; ii++) {
+    for (ii = 0; ii < s->num_files; ii++)
+    {
 
         // Is the file a PSRFITS file?
-        if (!is_PSRFITS(s->filenames[ii])) {
+        if (!is_PSRFITS(s->filenames[ii]))
+        {
             fprintf(stderr,
                     "\nError!  File '%s' does not appear to be PSRFITS!\n",
                     s->filenames[ii]);
@@ -180,10 +213,12 @@ void read_PSRFITS_files(struct spectra_info *s)
         fits_read_key(s->fitsfiles[ii], TSTRING, "OBS_MODE", ctmp, comment, &status);
         check_read_status("OBS_MODE");
         // Quick fix for Parkes DFB data (SRCH?  why????)...
-        if (strcmp("SRCH", ctmp) == 0) {
+        if (strcmp("SRCH", ctmp) == 0)
+        {
             strncpy(ctmp, "SEARCH", 40);
         }
-        if (strcmp(ctmp, "SEARCH")) {
+        if (strcmp(ctmp, "SEARCH"))
+        {
             fprintf(stderr,
                     "\nError!  File '%s' does not contain SEARCH-mode data!\n",
                     s->filenames[ii]);
@@ -192,7 +227,8 @@ void read_PSRFITS_files(struct spectra_info *s)
         // Now get the stuff we need from the primary HDU header
         fits_read_key(s->fitsfiles[ii], TSTRING, "TELESCOP", ctmp, comment, &status);
         // Quick fix for MockSpec data...
-        if (strcmp("ARECIBO 305m", ctmp) == 0) {
+        if (strcmp("ARECIBO 305m", ctmp) == 0)
+        {
             strncpy(ctmp, "Arecibo", 40);
         }
         // Quick fix for Parkes DFB data...
@@ -201,17 +237,21 @@ void read_PSRFITS_files(struct spectra_info *s)
 
             // Copy ctmp first since strlower() is in-place
             strcpy(newctmp, ctmp);
-            if (strcmp("parkes", strlower(remove_whitespace(newctmp))) == 0) {
+            if (strcmp("parkes", strlower(remove_whitespace(newctmp))) == 0)
+            {
                 strncpy(ctmp, "Parkes", 40);
             }
         }
-        if (status) {
+        if (status)
+        {
             printf("Error %d reading key %s\n", status, "TELESCOP");
             if (ii == 0)
                 s->telescope[0] = '\0';
             if (status == KEY_NO_EXIST)
                 status = 0;
-        } else {
+        }
+        else
+        {
             if (ii == 0)
                 strncpy(s->telescope, ctmp, 40);
             else if (strcmp(s->telescope, ctmp) != 0)
@@ -231,19 +271,20 @@ void read_PSRFITS_files(struct spectra_info *s)
         get_hdr_double("OBSFREQ", s->fctr);
         get_hdr_int("OBSNCHAN", s->orig_num_chan);
         get_hdr_double("OBSBW", s->orig_df);
-        //get_hdr_double("CHAN_DM", s->chan_dm);
+        // get_hdr_double("CHAN_DM", s->chan_dm);
         get_hdr_double("BMIN", s->beam_FWHM);
 
         /* This is likely not in earlier versions of PSRFITS */
         s->chan_dm = 0.0;
         fits_read_key(s->fitsfiles[ii], TDOUBLE, "CHAN_DM",
                       &(s->chan_dm), comment, &status);
-        if (status==KEY_NO_EXIST) status=0; // Prevents error messages on old files
+        if (status == KEY_NO_EXIST)
+            status = 0; // Prevents error messages on old files
         check_read_status("CHAN_DM");
         // Don't use the macros unless you are using the struct!
         fits_read_key(s->fitsfiles[ii], TINT, "STT_IMJD", &IMJD, comment, &status);
         check_read_status("STT_IMJD");
-        s->start_MJD[ii] = (long double) IMJD;
+        s->start_MJD[ii] = (long double)IMJD;
         fits_read_key(s->fitsfiles[ii], TINT, "STT_SMJD", &SMJD, comment, &status);
         check_read_status("STT_SMJD");
         fits_read_key(s->fitsfiles[ii], TDOUBLE, "STT_OFFS", &OFFS, comment,
@@ -252,11 +293,13 @@ void read_PSRFITS_files(struct spectra_info *s)
         BE_DELAY = 0.0; // Back-end delay.  Will only be applied to STT*-based times
         fits_read_key(s->fitsfiles[ii], TDOUBLE, "BE_DELAY", &BE_DELAY, comment,
                       &status);
-        if (status==KEY_NO_EXIST) status=0; // Prevents error messages on old files
+        if (status == KEY_NO_EXIST)
+            status = 0; // Prevents error messages on old files
         check_read_status("BE_DELAY");
-        s->start_MJD[ii] += ((long double) SMJD +
-                             (long double) OFFS +
-                             (long double) BE_DELAY) / SECPERDAY;
+        s->start_MJD[ii] += ((long double)SMJD +
+                             (long double)OFFS +
+                             (long double)BE_DELAY) /
+                            SECPERDAY;
 
         // Are we tracking?
         fits_read_key(s->fitsfiles[ii], TSTRING, "TRK_MODE", ctmp, comment, &status);
@@ -293,7 +336,8 @@ void read_PSRFITS_files(struct spectra_info *s)
         s->zero_offset = 0.0;
         fits_read_key(s->fitsfiles[ii], TFLOAT, "ZERO_OFF",
                       &(s->zero_offset), comment, &status);
-        if (status==KEY_NO_EXIST) status=0; // Prevents error messages on old files
+        if (status == KEY_NO_EXIST)
+            status = 0; // Prevents error messages on old files
         check_read_status("ZERO_OFF");
         s->zero_offset = fabs(s->zero_offset);
 
@@ -304,13 +348,19 @@ void read_PSRFITS_files(struct spectra_info *s)
 
             // Identify the OFFS_SUB column number
             fits_get_colnum(s->fitsfiles[ii], 0, "OFFS_SUB", &colnum, &status);
-            if (status == COL_NOT_FOUND) {
+            if (status == COL_NOT_FOUND)
+            {
                 printf("Warning!:  Can't find the OFFS_SUB column!\n");
-                status = 0;     // Reset status
-            } else {
-                if (ii == 0) {
+                status = 0; // Reset status
+            }
+            else
+            {
+                if (ii == 0)
+                {
                     s->offs_sub_col = colnum;
-                } else if (colnum != s->offs_sub_col) {
+                }
+                else if (colnum != s->offs_sub_col)
+                {
                     printf("Warning!:  OFFS_SUB column changes between files!\n");
                 }
             }
@@ -320,55 +370,63 @@ void read_PSRFITS_files(struct spectra_info *s)
                           s->offs_sub_col, 1L, 1L, 1L,
                           0, &offs_sub, &anynull, &status);
 
-            if (offs_sub != 0.0) {
-                numrows = (int) ((offs_sub - 0.5 * s->time_per_subint) /
-                                 s->time_per_subint + 1e-7);
+            if (offs_sub != 0.0)
+            {
+                numrows = (int)((offs_sub - 0.5 * s->time_per_subint) /
+                                    s->time_per_subint +
+                                1e-7);
                 // Check to see if any rows have been deleted or are missing
-                if (numrows > s->start_subint[ii]) {
+                if (numrows > s->start_subint[ii])
+                {
                     printf("Warning!:  NSUBOFFS reports %d previous rows\n"
                            "           but OFFS_SUB implies %d.  Using OFFS_SUB.\n"
                            "           Will likely be able to correct for this.\n",
                            s->start_subint[ii], numrows);
                 }
                 s->start_subint[ii] = numrows;
-            } else {
+            }
+            else
+            {
                 int indexval_col, jj;
                 offs_sub_are_zero = 1;
 
                 // If OFFS_SUB are all 0.0, then we will assume that there are
                 // no gaps in the file.  This isn't truly proper PSRFITS, but
                 // we should still be able to handle it
-                for (jj = 1; jj <= s->num_subint[ii]; jj++) {
+                for (jj = 1; jj <= s->num_subint[ii]; jj++)
+                {
                     fits_read_col(s->fitsfiles[ii], TDOUBLE,
                                   s->offs_sub_col, jj, 1L, 1L,
                                   0, &offs_sub, &anynull, &status);
-                    if (offs_sub != 0.0) {
+                    if (offs_sub != 0.0)
+                    {
                         offs_sub_are_zero = 0;
-                        perror
-                            ("Error!:  Some, but not all OFFS_SUB are 0.0.  Not good PSRFITS.\n");
+                        perror("Error!:  Some, but not all OFFS_SUB are 0.0.  Not good PSRFITS.\n");
                         exit(EXIT_FAILURE);
                     }
                 }
-                if (offs_sub_are_zero) {
-                    printf
-                        ("Warning!:  All OFFS_SUB are 0.0.  Assuming no missing rows.\n");
+                if (offs_sub_are_zero)
+                {
+                    printf("Warning!:  All OFFS_SUB are 0.0.  Assuming no missing rows.\n");
                 }
                 // Check to see if there is an INDEXVAL column.  That should tell
                 // us if we are missing any subints.  Use it in lieu of OFFS_SUB
                 fits_get_colnum(s->fitsfiles[ii], 0, "INDEXVAL", &indexval_col,
                                 &status);
-                if (status == COL_NOT_FOUND) {
-                    printf
-                        ("Warning!:  No INDEXVAL column, either.  This is not proper PSRFITS.\n");
+                if (status == COL_NOT_FOUND)
+                {
+                    printf("Warning!:  No INDEXVAL column, either.  This is not proper PSRFITS.\n");
                     status = 0; // Reset status
                     s->start_subint[ii] = 0;
-                } else {
+                }
+                else
+                {
                     double subint_index;
                     // Read INDEXVAL
                     fits_read_col(s->fitsfiles[ii], TDOUBLE,
                                   indexval_col, 1L, 1L, 1L,
                                   0, &subint_index, &anynull, &status);
-                    s->start_subint[ii] = (int) (subint_index + 1e-7 - 1.0);
+                    s->start_subint[ii] = (int)(subint_index + 1e-7 - 1.0);
                 }
             }
         }
@@ -380,11 +438,12 @@ void read_PSRFITS_files(struct spectra_info *s)
 
         // Compute the starting spectra from the times
         MJDf = s->start_MJD[ii] - s->start_MJD[0];
-        if (MJDf < 0.0) {
+        if (MJDf < 0.0)
+        {
             fprintf(stderr, "Error!: File %d seems to be from before file 0!\n", ii);
             exit(1);
         }
-        s->start_spec[ii] = (long long) (MJDf * SECPERDAY / s->dt + 0.5);
+        s->start_spec[ii] = (long long)(MJDf * SECPERDAY / s->dt + 0.5);
 
         // Now pull stuff from the other columns
         {
@@ -394,81 +453,101 @@ void read_PSRFITS_files(struct spectra_info *s)
 
             // Identify the data column and the data type
             fits_get_colnum(s->fitsfiles[ii], 0, "DATA", &colnum, &status);
-            if (status == COL_NOT_FOUND) {
+            if (status == COL_NOT_FOUND)
+            {
                 printf("Warning!:  Can't find the DATA column!\n");
-                status = 0;     // Reset status
-            } else {
-                if (ii == 0) {
+                status = 0; // Reset status
+            }
+            else
+            {
+                if (ii == 0)
+                {
                     s->data_col = colnum;
                     fits_get_coltype(s->fitsfiles[ii], colnum, &(s->FITS_typecode),
                                      &repeat, &width, &status);
                     // This makes CFITSIO treat 1-bit data as written in 'B' mode
                     // even if it was written in 'X' mode originally.  This means
                     // that we unpack it ourselves.
-                    if (s->bits_per_sample < 8 && s->FITS_typecode == 1) {
+                    if (s->bits_per_sample < 8 && s->FITS_typecode == 1)
+                    {
                         s->FITS_typecode = 11;
                     }
-                } else if (colnum != s->data_col) {
+                }
+                else if (colnum != s->data_col)
+                {
                     printf("Warning!:  DATA column changes between files!\n");
                 }
             }
 
             // Telescope azimuth
             fits_get_colnum(s->fitsfiles[ii], 0, "TEL_AZ", &colnum, &status);
-            if (status == COL_NOT_FOUND) {
+            if (status == COL_NOT_FOUND)
+            {
                 s->azimuth = 0.0;
-                status = 0;     // Reset status
-            } else {
+                status = 0; // Reset status
+            }
+            else
+            {
                 fits_read_col(s->fitsfiles[ii], TFLOAT, colnum,
                               1L, 1L, 1L, 0, &ftmp, &anynull, &status);
                 if (ii == 0)
-                    s->azimuth = (double) ftmp;
+                    s->azimuth = (double)ftmp;
             }
 
             // Telescope zenith angle
             fits_get_colnum(s->fitsfiles[ii], 0, "TEL_ZEN", &colnum, &status);
-            if (status == COL_NOT_FOUND) {
+            if (status == COL_NOT_FOUND)
+            {
                 s->zenith_ang = 0.0;
-                status = 0;     // Reset status
-            } else {
+                status = 0; // Reset status
+            }
+            else
+            {
                 fits_read_col(s->fitsfiles[ii], TFLOAT, colnum,
                               1L, 1L, 1L, 0, &ftmp, &anynull, &status);
                 if (ii == 0)
-                    s->zenith_ang = (double) ftmp;
+                    s->zenith_ang = (double)ftmp;
             }
 
             // Observing frequencies
             fits_get_colnum(s->fitsfiles[ii], 0, "DAT_FREQ", &colnum, &status);
-            if (status == COL_NOT_FOUND) {
+            if (status == COL_NOT_FOUND)
+            {
                 printf("Warning!:  Can't find the channel freq column!\n");
-                status = 0;     // Reset status
-            } else {
+                status = 0; // Reset status
+            }
+            else
+            {
                 int jj;
-                double *freqs = (double *) malloc(sizeof(double) * s->num_channels);
+                double *freqs = (double *)malloc(sizeof(double) * s->num_channels);
                 fits_read_col(s->fitsfiles[ii], TDOUBLE, colnum, 1L, 1L,
                               s->num_channels, 0, freqs, &anynull, &status);
 
-                if (ii == 0) {
+                if (ii == 0)
+                {
                     int trigger = 0;
-                    s->df = ((double) freqs[s->num_channels - 1] -
-                             (double) freqs[0]) / (double) (s->num_channels - 1);
+                    s->df = ((double)freqs[s->num_channels - 1] -
+                             (double)freqs[0]) /
+                            (double)(s->num_channels - 1);
                     s->lo_freq = freqs[0];
                     s->hi_freq = freqs[s->num_channels - 1];
                     // Now check that the channel spacing is the same throughout
-                    for (jj = 0; jj < s->num_channels - 1; jj++) {
+                    for (jj = 0; jj < s->num_channels - 1; jj++)
+                    {
                         ftmp = freqs[jj + 1] - freqs[jj];
-                        if ((fabs(ftmp - s->df) > 1e-7) && !trigger) {
+                        if ((fabs(ftmp - s->df) > 1e-7) && !trigger)
+                        {
                             trigger = 1;
-                            printf
-                                ("Warning!:  Channel spacing changes in file %d!\n",
-                                 ii);
+                            printf("Warning!:  Channel spacing changes in file %d!\n",
+                                   ii);
                         }
                     }
-                } else {
+                }
+                else
+                {
                     ftmp = fabs(s->df - (freqs[1] - freqs[0]));
                     if (ftmp > 1e-7)
-                        printf
-                            ("Warning!:  Channel spacing changes between files!\n");
+                        printf("Warning!:  Channel spacing changes between files!\n");
                     ftmp = fabs(s->lo_freq - freqs[0]);
                     if (ftmp > 1e-7)
                         printf("Warning!:  Low channel changes between files!\n");
@@ -481,23 +560,32 @@ void read_PSRFITS_files(struct spectra_info *s)
 
             // Data weights
             fits_get_colnum(s->fitsfiles[ii], 0, "DAT_WTS", &colnum, &status);
-            if (status == COL_NOT_FOUND) {
+            if (status == COL_NOT_FOUND)
+            {
                 printf("Warning!:  Can't find the channel weights!\n");
-                status = 0;     // Reset status
-            } else {
-                if (s->apply_weight < 0) {      // Use the data to decide
+                status = 0; // Reset status
+            }
+            else
+            {
+                if (s->apply_weight < 0)
+                { // Use the data to decide
                     int jj;
-                    if (ii == 0) {
+                    if (ii == 0)
+                    {
                         s->dat_wts_col = colnum;
-                    } else if (colnum != s->dat_wts_col) {
+                    }
+                    else if (colnum != s->dat_wts_col)
+                    {
                         printf("Warning!:  DAT_WTS column changes between files!\n");
                     }
-                    float *fvec = (float *) malloc(sizeof(float) * s->num_channels);
+                    float *fvec = (float *)malloc(sizeof(float) * s->num_channels);
                     fits_read_col(s->fitsfiles[ii], TFLOAT, s->dat_wts_col, 1L, 1L,
                                   s->num_channels, 0, fvec, &anynull, &status);
-                    for (jj = 0; jj < s->num_channels; jj++) {
+                    for (jj = 0; jj < s->num_channels; jj++)
+                    {
                         // If the weights are not 1, apply them
-                        if (fvec[jj] != 1.0) {
+                        if (fvec[jj] != 1.0)
+                        {
                             s->apply_weight = 1;
                             break;
                         }
@@ -505,31 +593,39 @@ void read_PSRFITS_files(struct spectra_info *s)
                     free(fvec);
                 }
                 if (s->apply_weight < 0)
-                    s->apply_weight = 0;        // not needed
+                    s->apply_weight = 0; // not needed
             }
 
             // Data offsets
             fits_get_colnum(s->fitsfiles[ii], 0, "DAT_OFFS", &colnum, &status);
-            if (status == COL_NOT_FOUND) {
+            if (status == COL_NOT_FOUND)
+            {
                 printf("Warning!:  Can't find the channel offsets!\n");
-                status = 0;     // Reset status
-            } else {
-                if (s->apply_offset < 0) {      // Use the data to decide
+                status = 0; // Reset status
+            }
+            else
+            {
+                if (s->apply_offset < 0)
+                { // Use the data to decide
                     int jj;
-                    if (ii == 0) {
+                    if (ii == 0)
+                    {
                         s->dat_offs_col = colnum;
-                    } else if (colnum != s->dat_offs_col) {
-                        printf
-                            ("Warning!:  DAT_OFFS column changes between files!\n");
                     }
-                    float *fvec = (float *) malloc(sizeof(float) *
-                                                   s->num_channels * s->num_polns);
+                    else if (colnum != s->dat_offs_col)
+                    {
+                        printf("Warning!:  DAT_OFFS column changes between files!\n");
+                    }
+                    float *fvec = (float *)malloc(sizeof(float) *
+                                                  s->num_channels * s->num_polns);
                     fits_read_col(s->fitsfiles[ii], TFLOAT, s->dat_offs_col, 1L, 1L,
                                   s->num_channels * s->num_polns,
                                   0, fvec, &anynull, &status);
-                    for (jj = 0; jj < s->num_channels * s->num_polns; jj++) {
+                    for (jj = 0; jj < s->num_channels * s->num_polns; jj++)
+                    {
                         // If the offsets are not 0, apply them
-                        if (fvec[jj] != 0.0) {
+                        if (fvec[jj] != 0.0)
+                        {
                             s->apply_offset = 1;
                             break;
                         }
@@ -537,30 +633,39 @@ void read_PSRFITS_files(struct spectra_info *s)
                     free(fvec);
                 }
                 if (s->apply_offset < 0)
-                    s->apply_offset = 0;        // not needed
+                    s->apply_offset = 0; // not needed
             }
 
             // Data scalings
             fits_get_colnum(s->fitsfiles[ii], 0, "DAT_SCL", &colnum, &status);
-            if (status == COL_NOT_FOUND) {
+            if (status == COL_NOT_FOUND)
+            {
                 printf("Warning!:  Can't find the channel scalings!\n");
-                status = 0;     // Reset status
-            } else {
-                if (s->apply_scale < 0) {       // Use the data to decide
+                status = 0; // Reset status
+            }
+            else
+            {
+                if (s->apply_scale < 0)
+                { // Use the data to decide
                     int jj;
-                    if (ii == 0) {
+                    if (ii == 0)
+                    {
                         s->dat_scl_col = colnum;
-                    } else if (colnum != s->dat_scl_col) {
+                    }
+                    else if (colnum != s->dat_scl_col)
+                    {
                         printf("Warning!:  DAT_SCL column changes between files!\n");
                     }
-                    float *fvec = (float *) malloc(sizeof(float) *
-                                                   s->num_channels * s->num_polns);
+                    float *fvec = (float *)malloc(sizeof(float) *
+                                                  s->num_channels * s->num_polns);
                     fits_read_col(s->fitsfiles[ii], TFLOAT, colnum, 1L, 1L,
                                   s->num_channels * s->num_polns,
                                   0, fvec, &anynull, &status);
-                    for (jj = 0; jj < s->num_channels * s->num_polns; jj++) {
+                    for (jj = 0; jj < s->num_channels * s->num_polns; jj++)
+                    {
                         // If the scales are not 1, apply them
-                        if (fvec[jj] != 1.0) {
+                        if (fvec[jj] != 1.0)
+                        {
                             s->apply_scale = 1;
                             break;
                         }
@@ -576,8 +681,10 @@ void read_PSRFITS_files(struct spectra_info *s)
         // that the _previous_ file has
         s->num_pad[ii] = 0;
         s->num_spec[ii] = s->spectra_per_subint * s->num_subint[ii];
-        if (ii > 0) {
-            if (s->start_spec[ii] > s->N) {     // Need padding
+        if (ii > 0)
+        {
+            if (s->start_spec[ii] > s->N)
+            { // Need padding
                 s->num_pad[ii - 1] = s->start_spec[ii] - s->N;
                 s->N += s->num_pad[ii - 1];
             }
@@ -604,11 +711,11 @@ void read_PSRFITS_files(struct spectra_info *s)
 
     // Is the data IQUV and the user poln is not set?
     if ((strncmp("IQUV", s->poln_order, 4) == 0) && (s->use_poln == 0))
-        s->use_poln = 1;        // 1st poln = I
+        s->use_poln = 1; // 1st poln = I
 
     // Calculate some others
     s->T = s->N * s->dt;
-    s->orig_df /= (double) s->orig_num_chan;
+    s->orig_df /= (double)s->orig_num_chan;
     s->samples_per_spectra = s->num_polns * s->num_channels;
     // Note:  the following is the number of bytes that will be in
     //        the returned array from CFITSIO, possibly after processing by
@@ -622,7 +729,8 @@ void read_PSRFITS_files(struct spectra_info *s)
     s->bytes_per_subint = s->bytes_per_spectra * s->spectra_per_subint;
 
     // Flip the band?
-    if (s->hi_freq < s->lo_freq) {
+    if (s->hi_freq < s->lo_freq)
+    {
         float ftmp = s->hi_freq;
         s->hi_freq = s->lo_freq;
         s->lo_freq = ftmp;
@@ -635,10 +743,13 @@ void read_PSRFITS_files(struct spectra_info *s)
     // Flip the bytes for Parkes FB_1BIT data
     if (s->bits_per_sample == 1 &&
         strcmp(s->telescope, "Parkes") == 0 &&
-        strcmp(s->backend, "FB_1BIT") == 0) {
+        strcmp(s->backend, "FB_1BIT") == 0)
+    {
         printf("Flipping bit ordering since Parkes FB_1BIT data.\n");
         s->flip_bytes = 1;
-    } else {
+    }
+    else
+    {
         s->flip_bytes = 0;
     }
 
@@ -664,14 +775,14 @@ void read_PSRFITS_files(struct spectra_info *s)
             weights[ii] = 1.0;
 }
 
-
 long long offset_to_PSRFITS_spectra(long long specnum, struct spectra_info *s)
 // This routine offsets into the PSRFITS files to the spectra
 // 'specnum'.  It returns the current spectra number.
 {
     int filenum = 0;
 
-    if (specnum > s->N) {
+    if (specnum > s->N)
+    {
         fprintf(stderr, "Error:  offset spectra %lld is > total spectra %lld\n\n",
                 specnum, s->N);
         exit(1);
@@ -687,7 +798,8 @@ long long offset_to_PSRFITS_spectra(long long specnum, struct spectra_info *s)
     numbuffered = 0;
 
     // Are we in a padding zone?
-    if (specnum > (s->start_spec[cur_file] + s->num_spec[cur_file])) {
+    if (specnum > (s->start_spec[cur_file] + s->num_spec[cur_file]))
+    {
         // "Seek" to the end of the file
         cur_subint = s->num_subint[cur_file] + 1;
         new_spec = s->start_spec[cur_file + 1];
@@ -695,7 +807,8 @@ long long offset_to_PSRFITS_spectra(long long specnum, struct spectra_info *s)
     }
     // Otherwise, "seek" to the spectra (really a whole subint)
     // Check to make sure that specnum is the start of a subint
-    if ((specnum - s->start_spec[cur_file]) % s->spectra_per_subint) {
+    if ((specnum - s->start_spec[cur_file]) % s->spectra_per_subint)
+    {
         fprintf(stderr,
                 "Error:  requested spectra %lld is not the start of a PSRFITS subint\n\n",
                 specnum);
@@ -707,7 +820,6 @@ long long offset_to_PSRFITS_spectra(long long specnum, struct spectra_info *s)
     return specnum;
 }
 
-
 int get_PSRFITS_rawblock(float *fdata, struct spectra_info *s, int *padding)
 // This routine reads a single block (i.e subint) from the input files
 // which contain raw data in PSRFITS format.  If padding is
@@ -726,7 +838,7 @@ int get_PSRFITS_rawblock(float *fdata, struct spectra_info *s, int *padding)
     // copy the previously offset part into the beginning.
     // New data comes after the old data in the buffer.
     if (numbuffered)
-        memcpy((char *) fdata, (char *) (fdata + numtoread * s->num_channels),
+        memcpy((char *)fdata, (char *)(fdata + numtoread * s->num_channels),
                numbuffered * s->num_channels * sizeof(float));
 
     // Make sure our current file number is valid
@@ -734,9 +846,11 @@ int get_PSRFITS_rawblock(float *fdata, struct spectra_info *s, int *padding)
         return 0;
 
     // Read a subint of data from the DATA col
-    if (cur_subint <= s->num_subint[cur_file]) {
+    if (cur_subint <= s->num_subint[cur_file])
+    {
         double offs_sub = 0.0;
-        if (!offs_sub_are_zero) {
+        if (!offs_sub_are_zero)
+        {
             // Read the OFFS_SUB column value in case there were dropped blocks
             fits_read_col(s->fitsfiles[cur_file], TDOUBLE,
                           s->offs_sub_col, cur_subint, 1L, 1L,
@@ -746,28 +860,34 @@ int get_PSRFITS_rawblock(float *fdata, struct spectra_info *s, int *padding)
             // Note: need to remove start_subint because that was already put
             // into start_spec.  This is important if initial rows are gone.
             new_spec = s->start_spec[cur_file] +
-                roundl((offs_sub - (s->start_subint[cur_file] + 0.5)
-                        * s->time_per_subint) / s->dt);
-        } else {
+                       roundl((offs_sub - (s->start_subint[cur_file] + 0.5) * s->time_per_subint) / s->dt);
+        }
+        else
+        {
             new_spec = s->start_spec[cur_file] +
-                (cur_subint - 1) * s->spectra_per_subint;
+                       (cur_subint - 1) * s->spectra_per_subint;
         }
 
-        //printf("cur/new_spec = %lld, %lld  s->start_spec[cur_file] = %lld\n",
-        //       cur_spec, new_spec, s->start_spec[cur_file]);
+        // printf("cur/new_spec = %lld, %lld  s->start_spec[cur_file] = %lld\n",
+        //        cur_spec, new_spec, s->start_spec[cur_file]);
 
         // The following determines if there were lost blocks, or if
         // we are putting different observations together so that
         // the blocks are not aligned
-        if (new_spec == cur_spec + numbuffered) {
+        if (new_spec == cur_spec + numbuffered)
+        {
             // if things look good, with no missing blocks, read the data
             get_PSRFITS_subint(fdataptr, cdatabuffer, s);
             cur_subint++;
             goto return_block;
-        } else {
+        }
+        else
+        {
             goto padding_block;
         }
-    } else {
+    }
+    else
+    {
         // We are going to move to the next file, so update
         // new_spec to be the starting spectra from the next file
         // so we can see if any padding is necessary
@@ -777,21 +897,25 @@ int get_PSRFITS_rawblock(float *fdata, struct spectra_info *s, int *padding)
             new_spec = cur_spec + numbuffered;
     }
 
-    if (new_spec == cur_spec + numbuffered) {
+    if (new_spec == cur_spec + numbuffered)
+    {
         // No padding is necessary, so switch files
         cur_file++;
         cur_subint = 1;
         return get_PSRFITS_rawblock(fdata, s, padding);
-    } else {                    // add padding
+    }
+    else
+    { // add padding
         goto padding_block;
     }
 
-  padding_block:
-    if (new_spec < cur_spec) {
+padding_block:
+    if (new_spec < cur_spec)
+    {
         // Files out of order?  Shouldn't get here.
         fprintf(stderr, "Error!:  Current subint has earlier time than previous!\n\n"
-                "\tfilename = '%s', subint = %d\n"
-                "\tcur_spec = %lld  new_spec = %lld\n",
+                        "\tfilename = '%s', subint = %d\n"
+                        "\tcur_spec = %lld  new_spec = %lld\n",
                 s->filenames[cur_file], cur_subint, cur_spec, new_spec);
         exit(1);
     }
@@ -806,16 +930,19 @@ int get_PSRFITS_rawblock(float *fdata, struct spectra_info *s, int *padding)
     *padding = 1;
     // If we haven't gotten a full block, or completed the buffered one
     // then recursively call get_PSRFITS_rawblock()
-    if (numbuffered) {
+    if (numbuffered)
+    {
         printf("Adding %d spectra of padding to buffer at subint %d\n",
                numtopad, cur_subint);
         return get_PSRFITS_rawblock(fdata, s, padding);
-    } else {
+    }
+    else
+    {
         printf("Adding %d spectra of padding at subint %d\n", numtopad, cur_subint);
         goto return_block;
     }
 
-  return_block:
+return_block:
     // Apply the corrections that need a full block
 
     // Invert the band if needed
@@ -833,6 +960,141 @@ int get_PSRFITS_rawblock(float *fdata, struct spectra_info *s, int *padding)
     return 1;
 }
 
+int get_PSRFITS_rawblock_log(float *fdata, struct spectra_info *s, int *padding, long long *data_size, long *total_microseconds)
+{
+    int numtopad = 0, numtoread, status = 0, anynull;
+    float *fdataptr = fdata;
+
+    fdataptr = fdata + numbuffered * s->num_channels;
+    // numtoread is always this size since we need to read
+    // full PSRFITS subints...
+    numtoread = s->spectra_per_subint;
+
+    // If our buffer array is offset from last time,
+    // copy the previously offset part into the beginning.
+    // New data comes after the old data in the buffer.
+    if (numbuffered)
+        memcpy((char *)fdata, (char *)(fdata + numtoread * s->num_channels),
+               numbuffered * s->num_channels * sizeof(float));
+
+    // Make sure our current file number is valid
+    if (cur_file >= s->num_files)
+        return 0;
+
+    // Read a subint of data from the DATA col
+    if (cur_subint <= s->num_subint[cur_file])
+    {
+        double offs_sub = 0.0;
+        if (!offs_sub_are_zero)
+        {
+            // Read the OFFS_SUB column value in case there were dropped blocks
+            fits_read_col(s->fitsfiles[cur_file], TDOUBLE,
+                          s->offs_sub_col, cur_subint, 1L, 1L,
+                          0, &offs_sub, &anynull, &status);
+            // Set new_spec to proper value, accounting for possibly
+            // missing initial rows of data and/or combining observations
+            // Note: need to remove start_subint because that was already put
+            // into start_spec.  This is important if initial rows are gone.
+            new_spec = s->start_spec[cur_file] +
+                       roundl((offs_sub - (s->start_subint[cur_file] + 0.5) * s->time_per_subint) / s->dt);
+        }
+        else
+        {
+            new_spec = s->start_spec[cur_file] +
+                       (cur_subint - 1) * s->spectra_per_subint;
+        }
+
+        // printf("cur/new_spec = %lld, %lld  s->start_spec[cur_file] = %lld\n",
+        //        cur_spec, new_spec, s->start_spec[cur_file]);
+
+        // The following determines if there were lost blocks, or if
+        // we are putting different observations together so that
+        // the blocks are not aligned
+        if (new_spec == cur_spec + numbuffered)
+        {
+            // if things look good, with no missing blocks, read the data
+            get_PSRFITS_subint_log(fdataptr, cdatabuffer, s, data_size, total_microseconds);
+            cur_subint++;
+            goto return_block;
+        }
+        else
+        {
+            goto padding_block;
+        }
+    }
+    else
+    {
+        // We are going to move to the next file, so update
+        // new_spec to be the starting spectra from the next file
+        // so we can see if any padding is necessary
+        if (cur_file < s->num_files - 1)
+            new_spec = s->start_spec[cur_file + 1];
+        else
+            new_spec = cur_spec + numbuffered;
+    }
+
+    if (new_spec == cur_spec + numbuffered)
+    {
+        // No padding is necessary, so switch files
+        cur_file++;
+        cur_subint = 1;
+        return get_PSRFITS_rawblock(fdata, s, padding);
+    }
+    else
+    { // add padding
+        goto padding_block;
+    }
+
+padding_block:
+    if (new_spec < cur_spec)
+    {
+        // Files out of order?  Shouldn't get here.
+        fprintf(stderr, "Error!:  Current subint has earlier time than previous!\n\n"
+                        "\tfilename = '%s', subint = %d\n"
+                        "\tcur_spec = %lld  new_spec = %lld\n",
+                s->filenames[cur_file], cur_subint, cur_spec, new_spec);
+        exit(1);
+    }
+    numtopad = new_spec - cur_spec;
+    // Don't add more than 1 block and if buffered, then realign the buffer
+    if (numtopad > (s->spectra_per_subint - numbuffered))
+        numtopad = s->spectra_per_subint - numbuffered;
+    add_padding(fdataptr, s->padvals, s->num_channels, numtopad);
+    // Update pointer into the buffer
+    numbuffered = (numbuffered + numtopad) % s->spectra_per_subint;
+    // Set the padding flag
+    *padding = 1;
+    // If we haven't gotten a full block, or completed the buffered one
+    // then recursively call get_PSRFITS_rawblock()
+    if (numbuffered)
+    {
+        printf("Adding %d spectra of padding to buffer at subint %d\n",
+               numtopad, cur_subint);
+        return get_PSRFITS_rawblock(fdata, s, padding);
+    }
+    else
+    {
+        printf("Adding %d spectra of padding at subint %d\n", numtopad, cur_subint);
+        goto return_block;
+    }
+
+return_block:
+    // Apply the corrections that need a full block
+
+    // Invert the band if needed
+    if (s->apply_flipband)
+        flip_band(fdata, s);
+
+    // Perform Zero-DMing if requested
+    if (s->remove_zerodm)
+        remove_zerodm(fdata, s);
+
+    // Increment our static counter (to determine how much data we
+    // have written on the fly).
+    cur_spec += s->spectra_per_subint;
+
+    return 1;
+}
 
 void get_PSRFITS_subint(float *fdata, unsigned char *cdata, struct spectra_info *s)
 {
@@ -841,7 +1103,324 @@ void get_PSRFITS_subint(float *fdata, unsigned char *cdata, struct spectra_info
     int numtoread = s->samples_per_subint;
 
     // The following allows us to read byte-packed data
-    if (s->bits_per_sample < 8) {
+    if (s->bits_per_sample < 8)
+    {
+        numtoread = (s->samples_per_subint * s->bits_per_sample) / 8;
+        ctmp = gen_bvect(numtoread);
+    }
+    // or 16-bit data that is listed as being bytes
+    if (s->bits_per_sample == 16 && s->FITS_typecode == 11)
+        numtoread = s->samples_per_subint * 2;
+
+    // Read the weights, offsets, and scales if required
+    if (s->apply_weight)
+        fits_read_col(s->fitsfiles[cur_file], TFLOAT, s->dat_wts_col, cur_subint, 1L,
+                      s->num_channels, 0, weights, &anynull, &status);
+    if (s->apply_offset)
+        fits_read_col(s->fitsfiles[cur_file], TFLOAT, s->dat_offs_col, cur_subint,
+                      1L, s->num_channels * s->num_polns, 0, offsets, &anynull,
+                      &status);
+    if (s->apply_scale)
+        fits_read_col(s->fitsfiles[cur_file], TFLOAT, s->dat_scl_col, cur_subint, 1L,
+                      s->num_channels * s->num_polns, 0, scales, &anynull, &status);
+
+    // Now actually read the subint into the temporary buffer
+    fits_read_col(s->fitsfiles[cur_file], s->FITS_typecode,
+                  s->data_col, cur_subint, 1L, numtoread,
+                  0, ctmp, &anynull, &status);
+
+    if (status)
+    {
+        fprintf(stderr, "Error!:  Problem reading record from PSRFITS data file\n"
+                        "\tfilename = '%s', subint = %d.  FITS status = %d.  Exiting.\n",
+                s->filenames[cur_file], cur_subint, status);
+        exit(1);
+    }
+    // The following converts that byte-packed data into bytes
+    if (s->bits_per_sample == 4)
+    {
+#ifdef _OPENMP
+#pragma omp parallel for default(none) shared(numtoread, cdata, ctmp)
+#endif
+        for (ii = 0; ii < numtoread; ii++)
+        {
+            const unsigned char uctmp = ctmp[ii];
+            const int jj = 2 * ii;
+            cdata[jj] = uctmp >> 4;
+            cdata[jj + 1] = uctmp & 0x0F;
+        }
+    }
+    else if (s->bits_per_sample == 2)
+    {
+#ifdef _OPENMP
+#pragma omp parallel for default(none) shared(numtoread, cdata, ctmp)
+#endif
+        for (ii = 0; ii < numtoread; ii++)
+        {
+            const unsigned char uctmp = ctmp[ii];
+            const int jj = 4 * ii;
+            cdata[jj] = ((uctmp >> 0x06) & 0x03);
+            cdata[jj + 1] = ((uctmp >> 0x04) & 0x03);
+            cdata[jj + 2] = ((uctmp >> 0x02) & 0x03);
+            cdata[jj + 3] = (uctmp & 0x03);
+        }
+    }
+    else if (s->bits_per_sample == 1)
+    {
+#ifdef _OPENMP
+#pragma omp parallel for default(none) shared(numtoread, cdata, ctmp)
+#endif
+        for (ii = 0; ii < numtoread; ii++)
+        {
+            const unsigned char uctmp = ctmp[ii];
+            const int jj = 8 * ii;
+            cdata[jj] = ((uctmp >> 0x07) & 0x01);
+            cdata[jj + 1] = ((uctmp >> 0x06) & 0x01);
+            cdata[jj + 2] = ((uctmp >> 0x05) & 0x01);
+            cdata[jj + 3] = ((uctmp >> 0x04) & 0x01);
+            cdata[jj + 4] = ((uctmp >> 0x03) & 0x01);
+            cdata[jj + 5] = ((uctmp >> 0x02) & 0x01);
+            cdata[jj + 6] = ((uctmp >> 0x01) & 0x01);
+            cdata[jj + 7] = (uctmp & 0x01);
+        }
+    }
+
+    if (s->bits_per_sample < 8)
+        vect_free(ctmp);
+
+    if (s->bits_per_sample == 1 && s->flip_bytes)
+    {
+        // Hack to flip each byte of data if needed
+        for (ii = 0; ii < s->bytes_per_subint / 8; ii++)
+        {
+            int jj;
+            const int offset = ii * 8;
+            for (jj = 0; jj < 4; jj++)
+            {
+                unsigned char uctmp = cdata[offset + jj];
+                cdata[offset + jj] = cdata[offset + 8 - 1 - jj];
+                cdata[offset + 8 - 1 - jj] = uctmp;
+            }
+        }
+    }
+    // Now convert all of the data into floats
+
+    // The following allows us to work with single polns out of many
+    // or to sum polarizations if required
+    if (s->num_polns > 1)
+    {
+        int sum_polns = 0;
+
+        if ((0 == strncmp(s->poln_order, "AABB", 4)) || (s->num_polns == 2))
+            sum_polns = 1;
+        // User chose which poln to use
+        if (s->use_poln > 0 || ((s->num_polns > 2) && !sum_polns))
+        {
+            const int idx = (s->use_poln - 1) * s->num_channels;
+            if (s->bits_per_sample == 16)
+            {
+#ifdef _OPENMP
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
+#endif
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
+                    int jj;
+                    float *fptr = fdata + ii * s->num_channels;
+                    const short *sptr =
+                        (short *)cdata + ii * s->samples_per_spectra + idx;
+                    for (jj = 0; jj < s->num_channels; jj++)
+                        fptr[jj] =
+                            (((float)sptr[jj] - s->zero_offset) * scales[idx + jj] +
+                             offsets[idx + jj]) *
+                            weights[jj];
+                }
+            }
+            else if (s->bits_per_sample == 32)
+            {
+#ifdef _OPENMP
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
+#endif
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
+                    int jj;
+                    float *fptr = fdata + ii * s->num_channels;
+                    const float *ftptr =
+                        (float *)cdata + ii * s->samples_per_spectra + idx;
+                    for (jj = 0; jj < s->num_channels; jj++)
+                        fptr[jj] =
+                            (((float)ftptr[jj] - s->zero_offset) * scales[idx +
+                                                                          jj] +
+                             offsets[idx + jj]) *
+                            weights[jj];
+                }
+            }
+            else
+            {
+#ifdef _OPENMP
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
+#endif
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
+                    int jj;
+                    float *fptr = fdata + ii * s->num_channels;
+                    const unsigned char *cptr =
+                        cdata + ii * s->samples_per_spectra + idx;
+                    for (jj = 0; jj < s->num_channels; jj++)
+                        fptr[jj] =
+                            (((float)cptr[jj] - s->zero_offset) * scales[idx + jj] +
+                             offsets[idx + jj]) *
+                            weights[jj];
+                }
+            }
+        }
+        else if (sum_polns)
+        { // sum the polns if there are 2 by default
+            const int idx = s->num_channels;
+            if (s->bits_per_sample == 16)
+            {
+#ifdef _OPENMP
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
+#endif
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
+                    int jj;
+                    float *fptr = fdata + ii * s->num_channels;
+                    const short *sptr =
+                        (short *)cdata + ii * s->samples_per_spectra;
+                    for (jj = 0; jj < s->num_channels; jj++)
+                    {
+                        fptr[jj] =
+                            (((float)sptr[jj] - s->zero_offset) * scales[jj] +
+                             offsets[jj]) *
+                            weights[jj];
+                        fptr[jj] +=
+                            (((float)sptr[jj + idx] - s->zero_offset) * scales[idx +
+                                                                               jj] +
+                             offsets[idx + jj]) *
+                            weights[jj];
+                    }
+                }
+            }
+            else if (s->bits_per_sample == 32)
+            {
+#ifdef _OPENMP
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
+#endif
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
+                    int jj;
+                    float *fptr = fdata + ii * s->num_channels;
+                    const float *ftptr =
+                        (float *)cdata + ii * s->samples_per_spectra;
+                    for (jj = 0; jj < s->num_channels; jj++)
+                    {
+                        fptr[jj] =
+                            (((float)ftptr[jj] - s->zero_offset) * scales[jj] +
+                             offsets[jj]) *
+                            weights[jj];
+                        fptr[jj] +=
+                            (((float)ftptr[jj + idx] -
+                              s->zero_offset) *
+                                 scales[idx + jj] +
+                             offsets[idx +
+                                     jj]) *
+                            weights[jj];
+                    }
+                }
+            }
+            else
+            {
+#ifdef _OPENMP
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
+#endif
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
+                    int jj;
+                    float *fptr = fdata + ii * s->num_channels;
+                    const unsigned char *cptr = cdata + ii * s->samples_per_spectra;
+                    for (jj = 0; jj < s->num_channels; jj++)
+                    {
+                        fptr[jj] =
+                            (((float)cptr[jj] - s->zero_offset) * scales[jj] +
+                             offsets[jj]) *
+                            weights[jj];
+                        fptr[jj] +=
+                            (((float)cptr[jj + idx] - s->zero_offset) * scales[idx +
+                                                                               jj] +
+                             offsets[idx + jj]) *
+                            weights[jj];
+                    }
+                }
+            }
+        }
+    }
+    else
+    { // This is for normal single-polarization data
+        if (s->bits_per_sample == 16)
+        {
+#ifdef _OPENMP
+#pragma omp parallel for default(none) shared(s, cdata, fdata, scales, offsets, weights)
+#endif
+            for (ii = 0; ii < s->spectra_per_subint; ii++)
+            {
+                int jj;
+                float *fptr = fdata + ii * s->num_channels;
+                const short *sptr = (short *)cdata + ii * s->samples_per_spectra;
+                for (jj = 0; jj < s->num_channels; jj++)
+                    fptr[jj] = (((float)sptr[jj] - s->zero_offset) * scales[jj] +
+                                offsets[jj]) *
+                               weights[jj];
+            }
+        }
+        else if (s->bits_per_sample == 32)
+        {
+#ifdef _OPENMP
+#pragma omp parallel for default(none) shared(s, cdata, fdata, scales, offsets, weights)
+#endif
+            for (ii = 0; ii < s->spectra_per_subint; ii++)
+            {
+                int jj;
+                float *fptr = fdata + ii * s->num_channels;
+                const float *ftptr = (float *)cdata + ii * s->samples_per_spectra;
+                for (jj = 0; jj < s->num_channels; jj++)
+                    fptr[jj] = (((float)ftptr[jj] - s->zero_offset) * scales[jj] +
+                                offsets[jj]) *
+                               weights[jj];
+            }
+        }
+        else
+        {
+#ifdef _OPENMP
+#pragma omp parallel for default(none) shared(s, cdata, fdata, scales, offsets, weights)
+#endif
+            for (ii = 0; ii < s->spectra_per_subint; ii++)
+            {
+                int jj;
+                float *fptr = fdata + ii * s->num_channels;
+                const unsigned char *cptr = cdata + ii * s->samples_per_spectra;
+                for (jj = 0; jj < s->num_channels; jj++)
+                    fptr[jj] = (((float)cptr[jj] - s->zero_offset) * scales[jj] +
+                                offsets[jj]) *
+                               weights[jj];
+            }
+        }
+    }
+}
+
+void get_PSRFITS_subint_log(float *fdata, unsigned char *cdata, struct spectra_info *s, long long *data_size, long *total_microseconds)
+{
+    struct timeval start, end; // 定义两个时间结构体
+    // 获取开始时间
+    gettimeofday(&start, NULL);
+
+    long long current_data_size = 0;
+    unsigned char *ctmp = cdata;
+    int ii, status = 0, anynull;
+    int numtoread = s->samples_per_subint;
+
+    // The following allows us to read byte-packed data
+    if (s->bits_per_sample < 8)
+    {
         numtoread = (s->samples_per_subint * s->bits_per_sample) / 8;
         ctmp = gen_bvect(numtoread);
     }
@@ -851,43 +1430,69 @@ void get_PSRFITS_subint(float *fdata, unsigned char *cdata, struct spectra_info
 
     // Read the weights, offsets, and scales if required
     if (s->apply_weight)
+    {
         fits_read_col(s->fitsfiles[cur_file], TFLOAT, s->dat_wts_col, cur_subint, 1L,
                       s->num_channels, 0, weights, &anynull, &status);
+        current_data_size += s->num_channels * sizeof(float);
+    }
     if (s->apply_offset)
+    {
         fits_read_col(s->fitsfiles[cur_file], TFLOAT, s->dat_offs_col, cur_subint,
                       1L, s->num_channels * s->num_polns, 0, offsets, &anynull,
                       &status);
+        current_data_size += s->num_channels * s->num_polns * sizeof(float);
+    }
     if (s->apply_scale)
+    {
         fits_read_col(s->fitsfiles[cur_file], TFLOAT, s->dat_scl_col, cur_subint, 1L,
                       s->num_channels * s->num_polns, 0, scales, &anynull, &status);
+        current_data_size += s->num_channels * s->num_polns * sizeof(float);
+    }
 
     // Now actually read the subint into the temporary buffer
     fits_read_col(s->fitsfiles[cur_file], s->FITS_typecode,
                   s->data_col, cur_subint, 1L, numtoread,
                   0, ctmp, &anynull, &status);
+    current_data_size += numtoread;
+    *data_size += current_data_size;
+    // 获取结束时间
+    gettimeofday(&end, NULL);
+
+    // 计算执行时间（单位：微秒）
+    long seconds = end.tv_sec - start.tv_sec;            // 秒部分的差值
+    long microseconds = end.tv_usec - start.tv_usec;     // 微秒部分的差值
+    *total_microseconds += seconds * 1000000 + microseconds; // 转换为总微秒
+    // printf("读取%.2f MB数据，耗时%d us\n", (double)current_data_size/(1024.0*1024.0), seconds * 1000000 + microseconds);
 
-    if (status) {
+
+    if (status)
+    {
         fprintf(stderr, "Error!:  Problem reading record from PSRFITS data file\n"
-                "\tfilename = '%s', subint = %d.  FITS status = %d.  Exiting.\n",
+                        "\tfilename = '%s', subint = %d.  FITS status = %d.  Exiting.\n",
                 s->filenames[cur_file], cur_subint, status);
         exit(1);
     }
     // The following converts that byte-packed data into bytes
-    if (s->bits_per_sample == 4) {
+    if (s->bits_per_sample == 4)
+    {
 #ifdef _OPENMP
-#pragma omp parallel for default(none) shared(numtoread,cdata,ctmp)
+#pragma omp parallel for default(none) shared(numtoread, cdata, ctmp)
 #endif
-        for (ii = 0; ii < numtoread; ii++) {
+        for (ii = 0; ii < numtoread; ii++)
+        {
             const unsigned char uctmp = ctmp[ii];
             const int jj = 2 * ii;
             cdata[jj] = uctmp >> 4;
             cdata[jj + 1] = uctmp & 0x0F;
         }
-    } else if (s->bits_per_sample == 2) {
+    }
+    else if (s->bits_per_sample == 2)
+    {
 #ifdef _OPENMP
-#pragma omp parallel for default(none) shared(numtoread,cdata,ctmp)
+#pragma omp parallel for default(none) shared(numtoread, cdata, ctmp)
 #endif
-        for (ii = 0; ii < numtoread; ii++) {
+        for (ii = 0; ii < numtoread; ii++)
+        {
             const unsigned char uctmp = ctmp[ii];
             const int jj = 4 * ii;
             cdata[jj] = ((uctmp >> 0x06) & 0x03);
@@ -895,11 +1500,14 @@ void get_PSRFITS_subint(float *fdata, unsigned char *cdata, struct spectra_info
             cdata[jj + 2] = ((uctmp >> 0x02) & 0x03);
             cdata[jj + 3] = (uctmp & 0x03);
         }
-    } else if (s->bits_per_sample == 1) {
+    }
+    else if (s->bits_per_sample == 1)
+    {
 #ifdef _OPENMP
-#pragma omp parallel for default(none) shared(numtoread,cdata,ctmp)
+#pragma omp parallel for default(none) shared(numtoread, cdata, ctmp)
 #endif
-        for (ii = 0; ii < numtoread; ii++) {
+        for (ii = 0; ii < numtoread; ii++)
+        {
             const unsigned char uctmp = ctmp[ii];
             const int jj = 8 * ii;
             cdata[jj] = ((uctmp >> 0x07) & 0x01);
@@ -916,12 +1524,15 @@ void get_PSRFITS_subint(float *fdata, unsigned char *cdata, struct spectra_info
     if (s->bits_per_sample < 8)
         vect_free(ctmp);
 
-    if (s->bits_per_sample == 1 && s->flip_bytes) {
+    if (s->bits_per_sample == 1 && s->flip_bytes)
+    {
         // Hack to flip each byte of data if needed
-        for (ii = 0; ii < s->bytes_per_subint / 8; ii++) {
+        for (ii = 0; ii < s->bytes_per_subint / 8; ii++)
+        {
             int jj;
             const int offset = ii * 8;
-            for (jj = 0; jj < 4; jj++) {
+            for (jj = 0; jj < 4; jj++)
+            {
                 unsigned char uctmp = cdata[offset + jj];
                 cdata[offset + jj] = cdata[offset + 8 - 1 - jj];
                 cdata[offset + 8 - 1 - jj] = uctmp;
@@ -932,155 +1543,201 @@ void get_PSRFITS_subint(float *fdata, unsigned char *cdata, struct spectra_info
 
     // The following allows us to work with single polns out of many
     // or to sum polarizations if required
-    if (s->num_polns > 1) {
+    if (s->num_polns > 1)
+    {
         int sum_polns = 0;
 
         if ((0 == strncmp(s->poln_order, "AABB", 4)) || (s->num_polns == 2))
             sum_polns = 1;
         // User chose which poln to use
-        if (s->use_poln > 0 || ((s->num_polns > 2) && !sum_polns)) {
+        if (s->use_poln > 0 || ((s->num_polns > 2) && !sum_polns))
+        {
             const int idx = (s->use_poln - 1) * s->num_channels;
-            if (s->bits_per_sample == 16) {
+            if (s->bits_per_sample == 16)
+            {
 #ifdef _OPENMP
-#pragma omp parallel for shared(s,cdata,fdata,scales,offsets,weights)
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
 #endif
-                for (ii = 0; ii < s->spectra_per_subint; ii++) {
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
                     int jj;
                     float *fptr = fdata + ii * s->num_channels;
                     const short *sptr =
-                        (short *) cdata + ii * s->samples_per_spectra + idx;
+                        (short *)cdata + ii * s->samples_per_spectra + idx;
                     for (jj = 0; jj < s->num_channels; jj++)
                         fptr[jj] =
-                            (((float) sptr[jj] - s->zero_offset) * scales[idx + jj] +
-                             offsets[idx + jj]) * weights[jj];
+                            (((float)sptr[jj] - s->zero_offset) * scales[idx + jj] +
+                             offsets[idx + jj]) *
+                            weights[jj];
                 }
-            } else if (s->bits_per_sample == 32) {
+            }
+            else if (s->bits_per_sample == 32)
+            {
 #ifdef _OPENMP
-#pragma omp parallel for shared(s,cdata,fdata,scales,offsets,weights)
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
 #endif
-                for (ii = 0; ii < s->spectra_per_subint; ii++) {
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
                     int jj;
                     float *fptr = fdata + ii * s->num_channels;
                     const float *ftptr =
-                        (float *) cdata + ii * s->samples_per_spectra + idx;
+                        (float *)cdata + ii * s->samples_per_spectra + idx;
                     for (jj = 0; jj < s->num_channels; jj++)
                         fptr[jj] =
-                            (((float) ftptr[jj] - s->zero_offset) * scales[idx +
-                                                                           jj] +
-                             offsets[idx + jj]) * weights[jj];
+                            (((float)ftptr[jj] - s->zero_offset) * scales[idx +
+                                                                          jj] +
+                             offsets[idx + jj]) *
+                            weights[jj];
                 }
-            } else {
+            }
+            else
+            {
 #ifdef _OPENMP
-#pragma omp parallel for shared(s,cdata,fdata,scales,offsets,weights)
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
 #endif
-                for (ii = 0; ii < s->spectra_per_subint; ii++) {
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
                     int jj;
                     float *fptr = fdata + ii * s->num_channels;
                     const unsigned char *cptr =
                         cdata + ii * s->samples_per_spectra + idx;
                     for (jj = 0; jj < s->num_channels; jj++)
                         fptr[jj] =
-                            (((float) cptr[jj] - s->zero_offset) * scales[idx + jj] +
-                             offsets[idx + jj]) * weights[jj];
+                            (((float)cptr[jj] - s->zero_offset) * scales[idx + jj] +
+                             offsets[idx + jj]) *
+                            weights[jj];
                 }
             }
-        } else if (sum_polns) { // sum the polns if there are 2 by default
+        }
+        else if (sum_polns)
+        { // sum the polns if there are 2 by default
             const int idx = s->num_channels;
-            if (s->bits_per_sample == 16) {
+            if (s->bits_per_sample == 16)
+            {
 #ifdef _OPENMP
-#pragma omp parallel for shared(s,cdata,fdata,scales,offsets,weights)
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
 #endif
-                for (ii = 0; ii < s->spectra_per_subint; ii++) {
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
                     int jj;
                     float *fptr = fdata + ii * s->num_channels;
                     const short *sptr =
-                        (short *) cdata + ii * s->samples_per_spectra;
-                    for (jj = 0; jj < s->num_channels; jj++) {
+                        (short *)cdata + ii * s->samples_per_spectra;
+                    for (jj = 0; jj < s->num_channels; jj++)
+                    {
                         fptr[jj] =
-                            (((float) sptr[jj] - s->zero_offset) * scales[jj] +
-                             offsets[jj]) * weights[jj];
+                            (((float)sptr[jj] - s->zero_offset) * scales[jj] +
+                             offsets[jj]) *
+                            weights[jj];
                         fptr[jj] +=
-                            (((float) sptr[jj + idx] - s->zero_offset) * scales[idx +
-                                                                                jj] +
-                             offsets[idx + jj]) * weights[jj];
+                            (((float)sptr[jj + idx] - s->zero_offset) * scales[idx +
+                                                                               jj] +
+                             offsets[idx + jj]) *
+                            weights[jj];
                     }
                 }
-            } else if (s->bits_per_sample == 32) {
+            }
+            else if (s->bits_per_sample == 32)
+            {
 #ifdef _OPENMP
-#pragma omp parallel for shared(s,cdata,fdata,scales,offsets,weights)
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
 #endif
-                for (ii = 0; ii < s->spectra_per_subint; ii++) {
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
                     int jj;
                     float *fptr = fdata + ii * s->num_channels;
                     const float *ftptr =
-                        (float *) cdata + ii * s->samples_per_spectra;
-                    for (jj = 0; jj < s->num_channels; jj++) {
+                        (float *)cdata + ii * s->samples_per_spectra;
+                    for (jj = 0; jj < s->num_channels; jj++)
+                    {
                         fptr[jj] =
-                            (((float) ftptr[jj] - s->zero_offset) * scales[jj] +
-                             offsets[jj]) * weights[jj];
+                            (((float)ftptr[jj] - s->zero_offset) * scales[jj] +
+                             offsets[jj]) *
+                            weights[jj];
                         fptr[jj] +=
-                            (((float) ftptr[jj + idx] -
-                              s->zero_offset) * scales[idx + jj] + offsets[idx +
-                                                                           jj]) *
+                            (((float)ftptr[jj + idx] -
+                              s->zero_offset) *
+                                 scales[idx + jj] +
+                             offsets[idx +
+                                     jj]) *
                             weights[jj];
                     }
                 }
-            } else {
+            }
+            else
+            {
 #ifdef _OPENMP
-#pragma omp parallel for shared(s,cdata,fdata,scales,offsets,weights)
+#pragma omp parallel for shared(s, cdata, fdata, scales, offsets, weights)
 #endif
-                for (ii = 0; ii < s->spectra_per_subint; ii++) {
+                for (ii = 0; ii < s->spectra_per_subint; ii++)
+                {
                     int jj;
                     float *fptr = fdata + ii * s->num_channels;
                     const unsigned char *cptr = cdata + ii * s->samples_per_spectra;
-                    for (jj = 0; jj < s->num_channels; jj++) {
+                    for (jj = 0; jj < s->num_channels; jj++)
+                    {
                         fptr[jj] =
-                            (((float) cptr[jj] - s->zero_offset) * scales[jj] +
-                             offsets[jj]) * weights[jj];
+                            (((float)cptr[jj] - s->zero_offset) * scales[jj] +
+                             offsets[jj]) *
+                            weights[jj];
                         fptr[jj] +=
-                            (((float) cptr[jj + idx] - s->zero_offset) * scales[idx +
-                                                                                jj] +
-                             offsets[idx + jj]) * weights[jj];
+                            (((float)cptr[jj + idx] - s->zero_offset) * scales[idx +
+                                                                               jj] +
+                             offsets[idx + jj]) *
+                            weights[jj];
                     }
                 }
             }
         }
-    } else {                    // This is for normal single-polarization data
-        if (s->bits_per_sample == 16) {
+    }
+    else
+    { // This is for normal single-polarization data
+        if (s->bits_per_sample == 16)
+        {
 #ifdef _OPENMP
-#pragma omp parallel for default(none) shared(s,cdata,fdata,scales,offsets,weights)
+#pragma omp parallel for default(none) shared(s, cdata, fdata, scales, offsets, weights)
 #endif
-            for (ii = 0; ii < s->spectra_per_subint; ii++) {
+            for (ii = 0; ii < s->spectra_per_subint; ii++)
+            {
                 int jj;
                 float *fptr = fdata + ii * s->num_channels;
-                const short *sptr = (short *) cdata + ii * s->samples_per_spectra;
+                const short *sptr = (short *)cdata + ii * s->samples_per_spectra;
                 for (jj = 0; jj < s->num_channels; jj++)
-                    fptr[jj] = (((float) sptr[jj] - s->zero_offset) * scales[jj] +
-                                offsets[jj]) * weights[jj];
+                    fptr[jj] = (((float)sptr[jj] - s->zero_offset) * scales[jj] +
+                                offsets[jj]) *
+                               weights[jj];
             }
-        } else if (s->bits_per_sample == 32) {
+        }
+        else if (s->bits_per_sample == 32)
+        {
 #ifdef _OPENMP
-#pragma omp parallel for default(none) shared(s,cdata,fdata,scales,offsets,weights)
+#pragma omp parallel for default(none) shared(s, cdata, fdata, scales, offsets, weights)
 #endif
-            for (ii = 0; ii < s->spectra_per_subint; ii++) {
+            for (ii = 0; ii < s->spectra_per_subint; ii++)
+            {
                 int jj;
                 float *fptr = fdata + ii * s->num_channels;
-                const float *ftptr = (float *) cdata + ii * s->samples_per_spectra;
+                const float *ftptr = (float *)cdata + ii * s->samples_per_spectra;
                 for (jj = 0; jj < s->num_channels; jj++)
-                    fptr[jj] = (((float) ftptr[jj] - s->zero_offset) * scales[jj] +
-                                offsets[jj]) * weights[jj];
+                    fptr[jj] = (((float)ftptr[jj] - s->zero_offset) * scales[jj] +
+                                offsets[jj]) *
+                               weights[jj];
             }
-        } else {
+        }
+        else
+        {
 #ifdef _OPENMP
-#pragma omp parallel for default(none) shared(s,cdata,fdata,scales,offsets,weights)
+#pragma omp parallel for default(none) shared(s, cdata, fdata, scales, offsets, weights)
 #endif
-            for (ii = 0; ii < s->spectra_per_subint; ii++) {
+            for (ii = 0; ii < s->spectra_per_subint; ii++)
+            {
                 int jj;
                 float *fptr = fdata + ii * s->num_channels;
                 const unsigned char *cptr = cdata + ii * s->samples_per_spectra;
                 for (jj = 0; jj < s->num_channels; jj++)
-                    fptr[jj] = (((float) cptr[jj] - s->zero_offset) * scales[jj] +
-                                offsets[jj]) * weights[jj];
+                    fptr[jj] = (((float)cptr[jj] - s->zero_offset) * scales[jj] +
+                                offsets[jj]) *
+                               weights[jj];
             }
         }
     }
diff --git a/src/realfft.c b/src/realfft.c
index 0123fc0..8ab788e 100644
--- a/src/realfft.c
+++ b/src/realfft.c
@@ -65,6 +65,9 @@ int main(int argc, char *argv[])
     printf("        by Scott M. Ransom\n\n");
 
     /* Get our file information */
+    long long data_size = 0;
+    long total_microseconds = 0;
+    struct timeval start, end; // 定义两个时间结构体
 
     numfiles = cmd->argc;
     for (int fi = 0 ; fi < numfiles ; fi++) {
@@ -231,7 +234,17 @@ int main(int argc, char *argv[])
             }
             printf("   Reading.\n");
             data = gen_fvect(numdata);
-            chkfread(data, sizeof(float), numdata, datfile);
+            if (cmd->IOlogP){
+                gettimeofday(&start, NULL);
+                chkfread(data, sizeof(float), numdata, datfile);
+                gettimeofday(&end, NULL);
+                long seconds = end.tv_sec - start.tv_sec;            // 秒部分的差值
+                long microseconds = end.tv_usec - start.tv_usec;     // 微秒部分的差值
+                total_microseconds += seconds * 1000000 + microseconds; // 转换为总微秒
+                data_size += numdata * sizeof(float);
+            }else{
+                chkfread(data, sizeof(float), numdata, datfile);
+            }
             printf("   Transforming.\n");
             realfft(data, numdata, isign);
             /* fftwcall((fcomplex *)data, numdata/2, isign); */
@@ -263,6 +276,14 @@ int main(int argc, char *argv[])
            ttim, utim, stim);
     printf("  Total time elapsed:  %.3f sec (%.3f sec/file)\n\n", tott, tott / numfiles);
 
+    if(cmd->IOlogP){
+        if ((numdata > MAXREALFFT || cmd->diskfftP) && !cmd->memfftP){
+            printf("IOlog: numdata too large and use out-core forward FFT\n");
+        }else{
+            printf("IOlog: %s read %.3f MB data, use %.3f ms, %.3f GB/s\n", cmd->full_cmd_line, (double)data_size/(1024.0*1024.0), (double)total_microseconds/(1000), ((double)data_size/(1024.0*1024.0*1024.0))/((double)total_microseconds/(1000000)));
+        }
+    }
+
     /*
        fftw_print_max_memory_usage();
        fftw_check_memory_leaks();
diff --git a/src/realfft_cmd.c b/src/realfft_cmd.c
index d737e0a..9565fcf 100644
--- a/src/realfft_cmd.c
+++ b/src/realfft_cmd.c
@@ -44,7 +44,9 @@ static Cmdline cmd = {
     /* argc = */ 0,
     /* argv = */ (char **) 0,
   /***** the original command line concatenated */
-    /* full_cmd_line = */ NULL
+    /* full_cmd_line = */ NULL,
+  /***** -IOlog: Print IO transfer log */
+    /* IOlogP = */ 0
 };
 
 /*@=null*/
@@ -828,6 +830,14 @@ void showOptionValues(void)
             printf("  value = `%s'\n", cmd.outdir);
         }
     }
+
+    /***** -IOlog: Print IO transfer log */
+    if( !cmd.IOlogP ) {
+        printf("-IOlog not found.\n");
+    } else {
+        printf("-IOlog found:\n");
+    }
+
     if (!cmd.argc) {
         printf("no remaining parameters in argv\n");
     } else {
@@ -924,6 +934,11 @@ Cmdline *parseCmdline(int argc, char **argv)
             continue;
         }
 
+        if( 0==strcmp("-IOlog", argv[i]) ) {
+            cmd.IOlogP = 1;
+            continue;
+        }
+
         if (argv[i][0] == '-') {
             fprintf(stderr, "\n%s: unknown option `%s'\n\n", Program, argv[i]);
             usage();
